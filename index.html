<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTFS Delay Dashboard – San Francisco</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            height: 100vh;
            overflow: hidden;
        }

        .dashboard-container {
            display: flex;
            height: 100vh;
            padding: 15px;
            gap: 15px;
        }

        .map-container {
            flex: 2;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .data-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            border-radius: 10px;
            background-color: #ffffff;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .controls {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex-shrink: 0;
        }

        .controls h1 {
            font-size: 1.1em;
            font-weight: 700;
            color: #2c3e50;
        }

        .controls p {
            font-size: 0.85em;
            color: #7f8c8d;
            line-height: 1.3;
        }

        .controls button {
            padding: 8px 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 0.9em;
            align-self: flex-start;
        }

        .controls button:hover {
            background-color: #2980b9;
        }

        .controls .status-line {
            font-size: 0.85em;
            color: #34495e;
        }

        .status-label {
            font-weight: 600;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            flex-shrink: 0;
        }

        .tab-button {
            padding: 15px 20px;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            transition: color 0.2s, border-bottom 0.2s;
        }

        .tab-button.active {
            color: #3498db;
            border-bottom: 3px solid #3498db;
        }

        .tab-content {
            padding: 15px;
            display: none;
            overflow-y: auto;
            flex-grow: 1;
            min-height: 0;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        .chart-container {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #fcfcfc;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            height: 350px;
            max-height: 50vh;
        }

        .chart-container h2 {
            font-size: 1.0em;
            color: #333;
            margin-bottom: 8px;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px;
        }

        .map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 1.0em;
            font-weight: bold;
            color: #2c3e50;
            text-align: center;
            padding: 10px;
        }

        .nearest-stops-label {
            font-size: 0.8em;
            color: #7f8c8d;
        }

        .nearest-stops-input {
            width: 60px;
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 0.85em;
            margin-left: 4px;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="map-container">
            <div id="map"></div>
            <div id="map-overlay" class="map-overlay">
                Loading metadata for San Francisco…<br>
                Once loaded, click anywhere on the map to explore nearby routes.
            </div>
        </div>

        <div class="data-container">
            <div class="controls">
                <h1>San Francisco GTFS Delay Explorer</h1>
                <p>
                    1) Click anywhere on the map to find nearby stops and routes.<br>
                    2) Click a route to focus it.<br>
                    3) Click a stop on that route to see delay patterns (both directions).
                </p>

                <div class="nearest-stops-label">
                    Nearest stops to use from click:
                    <input id="nearest-count" type="number" min="1" max="15" value="5" class="nearest-stops-input">
                </div>

                <button id="clear-route-btn">Clear Route Selection</button>

                <div class="status-line" id="selected-route-info">
                    <span class="status-label">Selected route:</span> None
                </div>
                <div class="status-line" id="selected-stop-info">
                    <span class="status-label">Selected stop:</span> None
                </div>
            </div>

            <div class="tabs">
                <div class="tab-button active" onclick="openTab(event, 'delays')">Delays</div>
                <div class="tab-button" onclick="openTab(event, 'accessibility')">Accessibility</div>
                <div class="tab-button" onclick="openTab(event, 'reliability')">Reliability</div>
            </div>

            <div id="delays" class="tab-content active">
                <p id="chart-message" style="flex-shrink:0; font-size:0.9em; color:#7f8c8d;">
                    Select a route and then a stop to see hourly and daily delay patterns (direction 0 & 1).
                </p>

                <div id="chart-area" style="display:none;">
                    <div class="chart-container">
                        <h2>Hourly Delay (Direction 0 &amp; 1)</h2>
                        <canvas id="hourlyDelayChart"></canvas>
                    </div>

                    <div class="chart-container">
                        <h2>Daily Delay (Direction 0 &amp; 1)</h2>
                        <canvas id="dailyDelayChart"></canvas>
                    </div>
                </div>
            </div>

            <div id="accessibility" class="tab-content">
                <p>Accessibility information will be displayed here.</p>
            </div>

            <div id="reliability" class="tab-content">
                <p>Reliability metrics will be displayed here.</p>
            </div>
        </div>
    </div>

    <script>
        // ---- Constants / Endpoints ----
        const SF_CENTER = [37.758458, -122.435435];

        const BASE_META_URL = "https://raw.githubusercontent.com/eco-trans/GTFS-UI/refs/heads/main/meta/san_francisco";
        const STOP_LOCATION_URL = `${BASE_META_URL}/stop_location.json`;
        const STOP_ROUTE_MAPPING_BASE = `${BASE_META_URL}/stop_route_mapping`;
        const ROUTE_STOP_MAPPING_BASE = `${BASE_META_URL}/route_stop_mapping`;
        const ROUTES_METADATA_URL = `${BASE_META_URL}/routes_metadata.json`;
        const STOPS_METADATA_URL = `${BASE_META_URL}/stops_metadata.json`;
        const ROUTE_DIR_STOP_DELAY_BASE = `${BASE_META_URL}/route_direction_stop_delay`;

        // ---- State ----
        let map;
        let metaLoaded = false;

        let stopLocations = null;      // {stop_id: [lat, lon]}
        let routesMetadata = null;     // {route_id: {name, color, link}}
        let stopsMetadata = null;      // {stop_id: {name, link}}

        let stopRouteMappingCache = {}; // stop_id -> [route_id, ...]
        let routeStopMappingCache = {}; // route_id -> [[stop_id, ...], ...]
        let delayDataCache = {};        // key "routeId_dir_stopId" -> [{t, delay}, ...]

        let routesLayerGroup;
        let stopsLayerGroup;
        let selectedRouteId = null;

        // stop_id -> { marker: L.circleMarker, routes: Set(route_ids) }
        let stopMarkerIndex = {};

        // route_id -> [L.Polyline,...]
        let routeLayerIndex = {};

        // Charts
        let hourlyDelayChart = null;
        let dailyDelayChart = null;

        // ---- Utility: Tabs ----
        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove("active");
            }

            const tabbuttons = document.getElementsByClassName("tab-button");
            for (let i = 0; i < tabbuttons.length; i++) {
                tabbuttons[i].className = tabbuttons[i].className.replace(" active", "");
            }

            const targetTab = document.getElementById(tabName);
            if (targetTab) {
                targetTab.style.display = "flex";
                targetTab.classList.add("active");
            }
            if (evt && evt.currentTarget) {
                evt.currentTarget.className += " active";
            }
        }

        // ---- Utility helpers ----
        function getNearestCount() {
            const input = document.getElementById("nearest-count");
            let k = parseInt(input.value, 10);
            if (isNaN(k) || k <= 0) k = 5;
            return Math.min(Math.max(k, 1), 50);
        }

        function euclideanDistance(lat1, lon1, lat2, lon2) {
            const dLat = lat1 - lat2;
            const dLon = lon1 - lon2;
            return Math.sqrt(dLat * dLat + dLon * dLon);
        }

        function computeMeanStd(values) {
            if (!values || values.length === 0) return { mean: null, std: null };
            const n = values.length;
            const sum = values.reduce((a, b) => a + b, 0);
            const mean = sum / n;
            const varSum = values.reduce((acc, v) => {
                const diff = v - mean;
                return acc + diff * diff;
            }, 0);
            const std = Math.sqrt(varSum / n);
            return { mean, std };
        }

        function groupByHour(samples) {
            // samples: [{t, delay}]
            const buckets = Array.from({ length: 24 }, () => []);
            samples.forEach(s => {
                const d = new Date(s.t * 1000);
                const hour = d.getHours(); // local hours
                buckets[hour].push(s.delay);
            });
            return buckets;
        }

        function groupByDate(samples) {
            const groups = {};
            samples.forEach(s => {
                const d = new Date(s.t * 1000);
                const dateStr = d.toISOString().split("T")[0];
                if (!groups[dateStr]) groups[dateStr] = [];
                groups[dateStr].push(s.delay);
            });
            return groups;
        }

        // ---- Metadata loading ----
        async function loadMetadata() {
            const overlay = document.getElementById("map-overlay");
            try {
                const [stopLocRes, routesMetaRes, stopsMetaRes] = await Promise.all([
                    fetch(STOP_LOCATION_URL),
                    fetch(ROUTES_METADATA_URL),
                    fetch(STOPS_METADATA_URL)
                ]);

                if (!stopLocRes.ok) throw new Error("stop_location.json failed");
                if (!routesMetaRes.ok) throw new Error("routes_metadata.json failed");
                if (!stopsMetaRes.ok) throw new Error("stops_metadata.json failed");

                stopLocations = await stopLocRes.json();
                routesMetadata = await routesMetaRes.json();
                stopsMetadata = await stopsMetaRes.json();

                metaLoaded = true;
                overlay.textContent = "Metadata loaded. Click on the map to explore nearby routes.";
                setTimeout(() => {
                    overlay.style.display = "none";
                }, 1000);
            } catch (err) {
                console.error(err);
                overlay.textContent = "Error loading metadata. Please refresh the page.";
            }
        }

        // ---- Map setup ----
        function initMap() {
            map = L.map('map').setView(SF_CENTER, 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            routesLayerGroup = L.layerGroup().addTo(map);
            stopsLayerGroup = L.layerGroup().addTo(map);

            map.on('click', onMapClick);
        }

        // ---- Map click: find nearest stops & draw routes ----
        async function onMapClick(e) {
            if (!metaLoaded) {
                alert("Metadata not loaded yet. Please wait a moment and try again.");
                return;
            }

            const overlay = document.getElementById("map-overlay");
            overlay.style.display = "flex";
            overlay.textContent = "Finding nearest stops and routes…";

            const { lat, lng } = e.latlng;
            const k = getNearestCount();

            try {
                const nearestStops = findNearestStops(lat, lng, k);
                const routeIds = await getRoutesForStops(nearestStops.map(s => s.stop_id));
                await drawRoutesAndStops(nearestStops, routeIds);

                overlay.style.display = "none";
            } catch (err) {
                console.error(err);
                overlay.textContent = "Error loading routes. See console for details.";
            }
        }

        function findNearestStops(lat, lon, k) {
            const all = [];
            for (const stopId in stopLocations) {
                const [sLat, sLon] = stopLocations[stopId];
                const dist = euclideanDistance(lat, lon, sLat, sLon);
                all.push({ stop_id: stopId, lat: sLat, lon: sLon, dist });
            }
            all.sort((a, b) => a.dist - b.dist);
            return all.slice(0, k);
        }

        async function getRoutesForStops(stopIds) {
            const routeSet = new Set();
            await Promise.all(stopIds.map(async (sid) => {
                if (!stopRouteMappingCache[sid]) {
                    const url = `${STOP_ROUTE_MAPPING_BASE}/${sid}.json`;
                    const res = await fetch(url);
                    if (!res.ok) {
                        console.warn(`No stop_route_mapping for stop ${sid}`);
                        stopRouteMappingCache[sid] = [];
                    } else {
                        stopRouteMappingCache[sid] = await res.json();
                    }
                }
                stopRouteMappingCache[sid].forEach(rid => routeSet.add(rid));
            }));
            return Array.from(routeSet);
        }

        async function drawRoutesAndStops(nearestStops, routeIds) {
            // Clear old layers & indices
            routesLayerGroup.clearLayers();
            stopsLayerGroup.clearLayers();
            routeLayerIndex = {};
            stopMarkerIndex = {};
            selectedRouteId = null;
            updateSelectedRouteInfo(null);
            updateSelectedStopInfo(null);
            clearCharts();

            // For each route, get stop sequences
            await Promise.all(routeIds.map(async (rid) => {
                if (!routeStopMappingCache[rid]) {
                    const url = `${ROUTE_STOP_MAPPING_BASE}/${rid}.json`;
                    const res = await fetch(url);
                    if (!res.ok) {
                        console.warn(`No route_stop_mapping for route ${rid}`);
                        routeStopMappingCache[rid] = [];
                    } else {
                        routeStopMappingCache[rid] = await res.json();
                    }
                }
            }));

            // Aggregate stops & build polylines
            const bounds = [];
            routeIds.forEach(routeId => {
                const sequences = routeStopMappingCache[routeId] || [];
                const routeMeta = routesMetadata[routeId] || {};
                const color = routeMeta.color || "#2980b9";

                routeLayerIndex[routeId] = [];

                sequences.forEach(seq => {
                    const latlngs = [];
                    seq.forEach(stopId => {
                        const loc = stopLocations[stopId];
                        if (!loc) return;
                        const [lat, lon] = loc;
                        latlngs.push([lat, lon]);
                        bounds.push([lat, lon]);

                        if (!stopMarkerIndex[stopId]) {
                            const stopMeta = stopsMetadata[stopId] || {};
                            const nearestTag = nearestStops.some(ns => ns.stop_id === stopId)
                                ? "<br><b>Near click</b>"
                                : "";

                            const marker = L.circleMarker([lat, lon], {
                                radius: 6,
                                color: '#34495e',
                                fillColor: '#3498db',
                                fillOpacity: 0.9
                            })
                                .bindPopup(
                                    `<b>${stopMeta.name || 'Stop ' + stopId}</b><br>` +
                                    `Stop ID: ${stopId}${nearestTag}` +
                                    (stopMeta.link ? `<br><a href="${stopMeta.link}" target="_blank">Info</a>` : "")
                                )
                                .on('click', () => onStopClick(stopId));

                            stopsLayerGroup.addLayer(marker);
                            stopMarkerIndex[stopId] = {
                                marker,
                                routes: new Set()
                            };
                        }
                        stopMarkerIndex[stopId].routes.add(routeId);
                    });

                    if (latlngs.length >= 2) {
                        const polyline = L.polyline(latlngs, {
                            color: color,
                            weight: 4,
                            opacity: 0.85
                        }).on('click', (e) => {
                            L.DomEvent.stopPropagation(e); // don't trigger map click
                            onRouteClick(routeId);
                        });

                        polyline.bindTooltip(
                            `${routeMeta.name || 'Route ' + routeId}`,
                            { sticky: true }
                        );

                        routesLayerGroup.addLayer(polyline);
                        routeLayerIndex[routeId].push(polyline);
                    }
                });
            });

            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [40, 40] });
            }
        }

        // ---- Route / Stop selection ----
        function updateSelectedRouteInfo(routeId) {
            const el = document.getElementById("selected-route-info");
            if (!routeId) {
                el.innerHTML = '<span class="status-label">Selected route:</span> None';
                return;
            }
            const meta = routesMetadata[routeId] || {};
            const label = meta.name || routeId;
            const link = meta.link
                ? ` (<a href="${meta.link}" target="_blank">route info</a>)`
                : "";
            el.innerHTML = `<span class="status-label">Selected route:</span> ${label} [${routeId}]${link}`;
        }

        function updateSelectedStopInfo(stopId) {
            const el = document.getElementById("selected-stop-info");
            if (!stopId) {
                el.innerHTML = '<span class="status-label">Selected stop:</span> None';
                return;
            }
            const meta = stopsMetadata[stopId] || {};
            const label = meta.name || stopId;
            const link = meta.link
                ? ` (<a href="${meta.link}" target="_blank">stop info</a>)`
                : "";
            el.innerHTML = `<span class="status-label">Selected stop:</span> ${label} [${stopId}]${link}`;
        }

        function onRouteClick(routeId) {
            selectedRouteId = routeId;
            updateSelectedRouteInfo(routeId);
            styleRoutesAndStopsForSelection();
        }

        function styleRoutesAndStopsForSelection() {
            // Routes
            Object.keys(routeLayerIndex).forEach(rid => {
                const meta = routesMetadata[rid] || {};
                const baseColor = meta.color || "#2980b9";
                const isSelected = selectedRouteId && rid === selectedRouteId;

                routeLayerIndex[rid].forEach(line => {
                    line.setStyle({
                        color: isSelected ? baseColor : "#bdc3c7",
                        opacity: isSelected ? 0.9 : 0.2,
                        weight: isSelected ? 5 : 3
                    });
                    if (isSelected) line.bringToFront();
                });
            });

            // Stops
            Object.keys(stopMarkerIndex).forEach(sid => {
                const entry = stopMarkerIndex[sid];
                const isOnSelected = !selectedRouteId || entry.routes.has(selectedRouteId);
                entry.marker.setStyle({
                    radius: isOnSelected ? 6 : 4,
                    fillOpacity: isOnSelected ? 0.9 : 0.25,
                    color: isOnSelected ? '#34495e' : '#bdc3c7',
                    fillColor: isOnSelected ? '#3498db' : '#ecf0f1'
                });
            });
        }

        function clearRouteSelection() {
            selectedRouteId = null;
            updateSelectedRouteInfo(null);
            styleRoutesAndStopsForSelection();
            clearCharts();
            updateSelectedStopInfo(null);
            document.getElementById("chart-message").style.display = "block";
            document.getElementById("chart-area").style.display = "none";
        }

        async function onStopClick(stopId) {
            if (!selectedRouteId) {
                alert("Please select a route first (click on a route line), then click a stop.");
                return;
            }
            updateSelectedStopInfo(stopId);

            try {
                const samplesDir0 = await getDelaySamples(selectedRouteId, 0, stopId);
                const samplesDir1 = await getDelaySamples(selectedRouteId, 1, stopId);

                const anyData = (samplesDir0.length + samplesDir1.length) > 0;
                if (!anyData) {
                    alert("No delay data found for this route / direction / stop combination.");
                    return;
                }

                document.getElementById("chart-message").style.display = "none";
                document.getElementById("chart-area").style.display = "block";

                renderCharts(samplesDir0, samplesDir1);
            } catch (err) {
                console.error(err);
                alert("Error loading delay data for this stop.");
            }
        }

        // ---- Delay fetching & processing ----
        async function getDelaySamples(routeId, directionId, stopId) {
            const key = `${routeId}_${directionId}_${stopId}`;
            if (delayDataCache[key]) return delayDataCache[key];

            const url = `${ROUTE_DIR_STOP_DELAY_BASE}/${routeId}/${directionId}/${stopId}.json`;
            const res = await fetch(url);
            if (!res.ok) {
                console.warn(`No delay data for ${key}`);
                delayDataCache[key] = [];
                return [];
            }
            const raw = await res.json();
            // raw format: [[unix_time, delay_sec], ...]
            const samples = raw.map(([t, d]) => ({
                t,
                delay: -d  // invert polarity as requested
            }));
            delayDataCache[key] = samples;
            return samples;
        }

        function clearCharts() {
            if (hourlyDelayChart) {
                hourlyDelayChart.destroy();
                hourlyDelayChart = null;
            }
            if (dailyDelayChart) {
                dailyDelayChart.destroy();
                dailyDelayChart = null;
            }
        }

        function renderCharts(samplesDir0, samplesDir1) {
            clearCharts();

            // Hourly groups
            const hourlyBuckets0 = groupByHour(samplesDir0);
            const hourlyBuckets1 = groupByHour(samplesDir1);

            const hourLabels = Array.from({ length: 24 }, (_, h) => h.toString().padStart(2, "0") + ":00");
            const hourlyMean0 = [];
            const hourlyStd0 = [];
            const hourlyMean1 = [];
            const hourlyStd1 = [];

            for (let h = 0; h < 24; h++) {
                const stats0 = computeMeanStd(hourlyBuckets0[h]);
                const stats1 = computeMeanStd(hourlyBuckets1[h]);
                hourlyMean0.push(stats0.mean);
                hourlyStd0.push(stats0.std);
                hourlyMean1.push(stats1.mean);
                hourlyStd1.push(stats1.std);
            }

            // Daily groups
            const dailyGroups0 = groupByDate(samplesDir0);
            const dailyGroups1 = groupByDate(samplesDir1);

            const allDatesSet = new Set([
                ...Object.keys(dailyGroups0),
                ...Object.keys(dailyGroups1)
            ]);
            const dateLabels = Array.from(allDatesSet).sort();

            const dailyMean0 = [];
            const dailyStd0 = [];
            const dailyMean1 = [];
            const dailyStd1 = [];

            dateLabels.forEach(dateStr => {
                const stats0 = computeMeanStd(dailyGroups0[dateStr] || []);
                const stats1 = computeMeanStd(dailyGroups1[dateStr] || []);
                dailyMean0.push(stats0.mean);
                dailyStd0.push(stats0.std);
                dailyMean1.push(stats1.mean);
                dailyStd1.push(stats1.std);
            });

            renderHourlyChart(hourLabels, hourlyMean0, hourlyStd0, hourlyMean1, hourlyStd1);
            renderDailyChart(dateLabels, dailyMean0, dailyStd0, dailyMean1, dailyStd1);
        }

        function renderHourlyChart(labels, mean0, std0, mean1, std1) {
            const ctx = document.getElementById("hourlyDelayChart").getContext("2d");

            const upper0 = mean0.map((m, i) => (m != null && std0[i] != null) ? m + std0[i] : null);
            const lower0 = mean0.map((m, i) => (m != null && std0[i] != null) ? m - std0[i] : null);
            const upper1 = mean1.map((m, i) => (m != null && std1[i] != null) ? m + std1[i] : null);
            const lower1 = mean1.map((m, i) => (m != null && std1[i] != null) ? m - std1[i] : null);

            hourlyDelayChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels,
                    datasets: [
                        // Direction 0 band
                        {
                            label: "Dir 0 Mean",
                            data: mean0,
                            borderWidth: 2,
                            fill: false,
                            tension: 0.25
                        },
                        {
                            label: "Dir 0 Upper",
                            data: upper0,
                            borderWidth: 0,
                            fill: "origin",
                            tension: 0.25
                        },
                        {
                            label: "Dir 0 Lower",
                            data: lower0,
                            borderWidth: 0,
                            fill: "-1",
                            tension: 0.25
                        },
                        // Direction 1 band
                        {
                            label: "Dir 1 Mean",
                            data: mean1,
                            borderWidth: 2,
                            fill: false,
                            tension: 0.25
                        },
                        {
                            label: "Dir 1 Upper",
                            data: upper1,
                            borderWidth: 0,
                            fill: "origin",
                            tension: 0.25
                        },
                        {
                            label: "Dir 1 Lower",
                            data: lower1,
                            borderWidth: 0,
                            fill: "-1",
                            tension: 0.25
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                filter: (item) => {
                                    // show only mean labels in legend
                                    return item.datasetIndex === 0 || item.datasetIndex === 3;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: "Hour of day" }
                        },
                        y: {
                            title: { display: true, text: "Delay (sec, polarity flipped)" }
                        }
                    }
                }
            });
        }

        function renderDailyChart(labels, mean0, std0, mean1, std1) {
            const ctx = document.getElementById("dailyDelayChart").getContext("2d");

            const upper0 = mean0.map((m, i) => (m != null && std0[i] != null) ? m + std0[i] : null);
            const lower0 = mean0.map((m, i) => (m != null && std0[i] != null) ? m - std0[i] : null);
            const upper1 = mean1.map((m, i) => (m != null && std1[i] != null) ? m + std1[i] : null);
            const lower1 = mean1.map((m, i) => (m != null && std1[i] != null) ? m - std1[i] : null);

            dailyDelayChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels,
                    datasets: [
                        // Dir 0
                        {
                            label: "Dir 0 Mean",
                            data: mean0,
                            borderWidth: 2,
                            fill: false,
                            tension: 0.25
                        },
                        {
                            label: "Dir 0 Upper",
                            data: upper0,
                            borderWidth: 0,
                            fill: "origin",
                            tension: 0.25
                        },
                        {
                            label: "Dir 0 Lower",
                            data: lower0,
                            borderWidth: 0,
                            fill: "-1",
                            tension: 0.25
                        },
                        // Dir 1
                        {
                            label: "Dir 1 Mean",
                            data: mean1,
                            borderWidth: 2,
                            fill: false,
                            tension: 0.25
                        },
                        {
                            label: "Dir 1 Upper",
                            data: upper1,
                            borderWidth: 0,
                            fill: "origin",
                            tension: 0.25
                        },
                        {
                            label: "Dir 1 Lower",
                            data: lower1,
                            borderWidth: 0,
                            fill: "-1",
                            tension: 0.25
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                filter: (item) => {
                                    return item.datasetIndex === 0 || item.datasetIndex === 3;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: "Date" }
                        },
                        y: {
                            title: { display: true, text: "Delay (sec, polarity flipped)" }
                        }
                    }
                }
            });
        }

        // ---- Init ----
        document.addEventListener("DOMContentLoaded", () => {
            initMap();
            loadMetadata();

            const clearBtn = document.getElementById("clear-route-btn");
            clearBtn.addEventListener("click", clearRouteSelection);

            // activate Delays tab properly on load
            const activeTabButton = document.querySelector(".tabs .tab-button.active");
            if (activeTabButton) {
                openTab({ currentTarget: activeTabButton }, "delays");
            }
        });
    </script>
</body>
</html>
