<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GTFS Delay Dashboard – San Francisco</title>

    <!-- Leaflet -->
    <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            height: 100vh;
            overflow: hidden;
        }

        .dashboard-container {
            display: flex;
            height: 100vh;
            padding: 15px;
            gap: 15px;
        }

        .map-container {
            flex: 2;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        #map-overlay {
            position: absolute;
            top: 12px;
            left: 12px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 6px;
            font-size: 0.8rem;
            color: #34495e;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
            z-index: 500;
        }

        .data-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            border-radius: 10px;
            background-color: #ffffff;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .controls {
            padding: 14px 16px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
        }

        .controls h1 {
            font-size: 1.05rem;
            font-weight: 700;
            color: #2c3e50;
        }

        .controls p {
            font-size: 0.82rem;
            color: #7f8c8d;
            line-height: 1.3;
        }

        .status-line {
            display: flex;
            flex-wrap: wrap;
            gap: 6px 12px;
            font-size: 0.8rem;
            color: #2c3e50;
        }

        .status-pill {
            padding: 3px 8px;
            border-radius: 999px;
            background: #ecf0f1;
        }

        .controls button {
            align-self: flex-start;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #d0d7de;
            background: #f5f7fa;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s;
        }

        .controls button:hover {
            background: #e6f2fb;
            border-color: #3498db;
        }

        .tab-content {
            flex: 1;
            padding: 10px 14px 12px;
            overflow-y: auto;
        }

        .chart-container {
            background: #ffffff;
            border-radius: 10px;
            padding: 10px 12px 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .chart-container h2 {
            font-size: 0.95rem;
            margin-bottom: 6px;
            color: #2c3e50;
        }

        .list-section {
            margin-top: 8px;
            font-size: 0.84rem;
        }

        .list-section h3 {
            font-size: 0.88rem;
            margin-bottom: 4px;
            color: #2c3e50;
        }

        .pill-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .pill-button {
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid #d0d7de;
            background-color: #f8fafc;
            font-size: 0.78rem;
            cursor: pointer;
            transition: background-color 0.15s, border-color 0.15s, color 0.15s;
        }

        .pill-button:hover {
            background-color: #e6f2fb;
            border-color: #3498db;
        }

        .pill-button.selected {
            background-color: #3498db;
            color: #ffffff;
            border-color: #2980b9;
        }

        #chart-area {
            display: none;
            display: grid;
            grid-template-columns: 1fr;
            grid-auto-rows: 420px;
            gap: 14px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="map-container">
            <div id="map"></div>
            <div id="map-overlay">Loading metadata…</div>
        </div>

        <div class="data-container">
            <div class="controls">
                <h1>San Francisco Transit Delay</h1>
                <p>
                    Hover a shaded area to see its delay distribution. Click an area
                    to explore routes, then select a route and stop to view
                    stop-level delay patterns.
                </p>
                <div class="status-line">
                    <span class="status-pill"
                        id="selected-route-label">Route: none</span>
                    <span class="status-pill"
                        id="selected-stop-label">Stop: none</span>
                </div>
                <button type="button" onclick="clearRouteSelection()">
                    Clear route selection
                </button>
            </div>

            <div id="delays" class="tab-content">
                <!-- Polygon-level stats -->
                <div
                    id="polygon-stats"
                    style="width: 100%; display: block; margin-bottom: 10px"
                >
                    <div class="chart-container" style="min-height: 260px">
                        <h2>Area Delay Distribution</h2>
                        <canvas id="polygonHistogramChart"></canvas>
                    </div>
                </div>

                <!-- Route list (when polygon clicked) -->
                <div
                    id="route-list-section"
                    class="list-section"
                    style="display: none"
                >
                    <h3>Routes in selected area</h3>
                    <div id="route-list" class="pill-list"></div>
                </div>

                <!-- Stop list (when route selected) -->
                <div
                    id="stop-list-section"
                    class="list-section"
                    style="display: none"
                >
                    <h3>Stops on selected route</h3>
                    <div id="stop-list" class="pill-list"></div>
                </div>

                <!-- Stop-level delay charts -->
                <div
                    id="chart-area"
                    style="
                        display: none;
                        grid-template-columns: 1fr;
                        grid-auto-rows: 420px;
                        gap: 14px;
                        margin-top: 12px;
                    "
                >
                    <div class="chart-container" id="hourlyDir0Container">
                        <h2>Hourly delay</h2>
                        <canvas id="hourlyDelayChartDir0"></canvas>
                    </div>

                    <div class="chart-container" id="hourlyDir1Container">
                        <h2>Hourly delay</h2>
                        <canvas id="hourlyDelayChartDir1"></canvas>
                    </div>

                    <div class="chart-container" id="dailyDir0Container">
                        <h2>Daily delay</h2>
                        <canvas id="dailyDelayChartDir0"></canvas>
                    </div>

                    <div class="chart-container" id="dailyDir1Container">
                        <h2>Daily delay</h2>
                        <canvas id="dailyDelayChartDir1"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Constants -------------------------------------------------------

        const SF_CENTER = [37.758458, -122.435435];

        const BASE_META_URL =
            "https://raw.githubusercontent.com/eco-trans/GTFS-UI/refs/heads/main/meta/san_francisco";

        const STOP_LOCATION_URL = `${BASE_META_URL}/stop_location.json`;
        const STOP_ROUTE_MAPPING_BASE = `${BASE_META_URL}/stop_route_mapping`;
        const ROUTES_METADATA_URL = `${BASE_META_URL}/routes_metadata.json`;
        const STOPS_METADATA_URL = `${BASE_META_URL}/stops_metadata.json`;
        const ROUTE_EDGES_BASE = `${BASE_META_URL}/route_edges`;
        const ROUTE_DIR_STOP_DELAY_BASE = `${BASE_META_URL}/route_direction_stop_delay`;

        const POLYGONS_URL = `${BASE_META_URL}/polygons.geojson`;
        const POLYGON_STOP_MAPPING_URL = `${BASE_META_URL}/polygon_stop_mapping.json`;
        const SPATIAL_DELAY_URL = `${BASE_META_URL}/spatial_delay_data.json`;

        // --- Global state ----------------------------------------------------

        let map;
        let polygonsLayer;
        let routesLayerGroup;
        let stopsLayerGroup;

        let stopLocations = null;
        let routesMetadata = {};
        let stopsMetadata = {};

        let polygonsGeoJson = null;
        let polygonStopMapping = null;
        let spatialDelayData = null;

        let polygonMeanDelays = {};
        let polygonMinMean = null;
        let polygonMaxMean = null;

        let stopRouteMappingCache = {};
        let routeEdgesCache = {};
        let routeLayerIndex = {};
        let stopMarkerIndex = {}; // stopId -> { marker, routes: Set }

        let selectedPolygonGid = null;
        let selectedRouteId = null;
        let selectedStopId = null;

        let polygonHistogramChart = null;
        let hourlyDelayChartDir0 = null;
        let hourlyDelayChartDir1 = null;
        let dailyDelayChartDir0 = null;
        let dailyDelayChartDir1 = null;

        let metaLoaded = false;

        // --- Init ------------------------------------------------------------

        document.addEventListener("DOMContentLoaded", () => {
            initMap();
            loadMetadata();
        });

        function initMap() {
            map = L.map("map").setView(SF_CENTER, 13);

            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                attribution: "&copy; OpenStreetMap contributors",
            }).addTo(map);

            polygonsLayer = L.layerGroup().addTo(map);
            routesLayerGroup = L.layerGroup().addTo(map);
            stopsLayerGroup = L.layerGroup().addTo(map);
        }

        async function loadMetadata() {
            const overlay = document.getElementById("map-overlay");
            try {
                const [
                    stopLocRes,
                    routesMetaRes,
                    stopsMetaRes,
                    polysRes,
                    polyStopRes,
                    spatialRes,
                ] = await Promise.all([
                    fetch(STOP_LOCATION_URL),
                    fetch(ROUTES_METADATA_URL),
                    fetch(STOPS_METADATA_URL),
                    fetch(POLYGONS_URL),
                    fetch(POLYGON_STOP_MAPPING_URL),
                    fetch(SPATIAL_DELAY_URL),
                ]);

                if (!stopLocRes.ok) throw new Error("stop_location.json failed");
                if (!routesMetaRes.ok)
                    throw new Error("routes_metadata.json failed");
                if (!stopsMetaRes.ok) throw new Error("stops_metadata.json failed");
                if (!polysRes.ok) throw new Error("polygons.geojson failed");
                if (!polyStopRes.ok)
                    throw new Error("polygon_stop_mapping.json failed");
                if (!spatialRes.ok)
                    throw new Error("spatial_delay_data.json failed");

                stopLocations = await stopLocRes.json();
                routesMetadata = await routesMetaRes.json();
                stopsMetadata = await stopsMetaRes.json();
                polygonsGeoJson = await polysRes.json();
                polygonStopMapping = await polyStopRes.json();
                spatialDelayData = await spatialRes.json();

                // Preprocess spatial delay: flip polarity & compute global min/max
                const means = [];
                polygonMeanDelays = {};
                for (const gid of Object.keys(spatialDelayData)) {
                    const entry = spatialDelayData[gid];
                    if (!Array.isArray(entry) || entry.length < 2) continue;
                    const meanRaw = entry[0];
                    const hist = entry[1];

                    if (typeof meanRaw === "number") {
                        const meanFlipped = -meanRaw; // flip polarity
                        polygonMeanDelays[gid] = meanFlipped;
                        means.push(meanFlipped);
                    }

                    // histogram: [freqs, values] – flip polarity of values
                    if (Array.isArray(hist) && hist.length === 2) {
                        const bins = hist[1];
                        if (Array.isArray(bins)) {
                            hist[1] = bins.map((v) => -v);
                        }
                    }
                }
                polygonMinMean = means.length ? Math.min(...means) : null;
                polygonMaxMean = means.length ? Math.max(...means) : null;

                metaLoaded = true;
                overlay.textContent =
                    "Hover a shaded area to see its delay distribution. Click to explore routes.";
                setTimeout(() => {
                    overlay.style.display = "none";
                }, 1500);

                initPolygonsLayer();
            } catch (err) {
                console.error(err);
                overlay.textContent =
                    "Error loading metadata. Please refresh the page.";
            }
        }

        // --- Polygon rendering & interaction --------------------------------

        function colorForPolygonMean(meanVal) {
            if (
                meanVal == null ||
                polygonMinMean == null ||
                polygonMaxMean == null
            ) {
                return "#d7dde5";
            }
            const min = polygonMinMean;
            const max = polygonMaxMean;
            const span = max - min || 1;
            let t = (meanVal - min) / span;
            t = Math.max(0, Math.min(1, t));
            // interpolate between light yellow (#fff7bc) and deep red (#e34a33)
            const c1 = [0xff, 0xf7, 0xbc];
            const c2 = [0xe3, 0x4a, 0x33];
            const r = Math.round(c1[0] + t * (c2[0] - c1[0]));
            const g = Math.round(c1[1] + t * (c2[1] - c1[1]));
            const b = Math.round(c1[2] + t * (c2[2] - c1[2]));
            return `rgb(${r},${g},${b})`;
        }

        function initPolygonsLayer() {
            if (!polygonsGeoJson) return;

            polygonsLayer.clearLayers();

            polygonsLayer = L.geoJSON(polygonsGeoJson, {
                style: (feature) => {
                    const gid =
                        feature.properties && feature.properties.gid != null
                            ? String(feature.properties.gid)
                            : null;
                    const meanVal =
                        gid && polygonMeanDelays[gid] != null
                            ? polygonMeanDelays[gid]
                            : null;
                    return {
                        color: "#666",
                        weight: 1,
                        fillColor: colorForPolygonMean(meanVal),
                        fillOpacity: 0.5,
                    };
                },
                onEachFeature: (feature, layer) => {
                    const gid =
                        feature.properties && feature.properties.gid != null
                            ? String(feature.properties.gid)
                            : null;
                    if (!gid) return;

                    layer.on("mouseover", () => {
                        showPolygonHistogram(gid);
                    });

                    layer.on("click", (e) => {
                        L.DomEvent.stopPropagation(e);
                        onPolygonClick(gid);
                    });
                },
            }).addTo(map);
        }

        function showPolygonHistogram(gid) {
            if (!spatialDelayData) return;
            const entry = spatialDelayData[gid];
            if (!entry || entry.length < 2) return;
            const hist = entry[1];
            if (!Array.isArray(hist) || hist.length < 2) return;
            const freqs = hist[0];
            const bins = hist[1];
            if (!Array.isArray(freqs) || !Array.isArray(bins)) return;

            const canvas = document.getElementById("polygonHistogramChart");
            if (!canvas) return;
            const ctx = canvas.getContext("2d");

            if (polygonHistogramChart) {
                polygonHistogramChart.destroy();
                polygonHistogramChart = null;
            }

            polygonHistogramChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: bins.map((v) => v.toFixed(0)), // delay in seconds
                    datasets: [
                        {
                            label: "Frequency",
                            data: freqs,
                            backgroundColor: "rgba(52, 152, 219, 0.55)",
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "Delay (sec, polarity flipped)",
                            },
                        },
                        y: {
                            title: { display: true, text: "Count" },
                        },
                    },
                },
            });
        }

        async function onPolygonClick(gid) {
            if (!metaLoaded) return;

            selectedPolygonGid = gid;
            selectedRouteId = null;
            selectedStopId = null;

            updateSelectedRouteInfo();
            updateSelectedStopInfo();
            clearCharts();

            // Route/stop list visibility
            document.getElementById("route-list-section").style.display =
                "block";
            document.getElementById("stop-list-section").style.display = "none";
            document.getElementById("chart-area").style.display = "none";

            // Determine stops in polygon and routes serving them
            const stopIds = polygonStopMapping[gid] || [];
            const routeIds = await getRoutesForStops(stopIds);

            await drawRoutesAndStopsForPolygon(stopIds, routeIds);
            populateRouteList(routeIds);
        }

        // --- Routes & stops --------------------------------------------------

        async function getRoutesForStops(stopIds) {
            const routeSet = new Set();
            await Promise.all(
                stopIds.map(async (sid) => {
                    const key = String(sid);
                    if (!stopRouteMappingCache[key]) {
                        const url = `${STOP_ROUTE_MAPPING_BASE}/${key}.json`;
                        try {
                            const res = await fetch(url);
                            if (!res.ok) {
                                console.warn(
                                    "No stop_route_mapping for stop",
                                    key
                                );
                                stopRouteMappingCache[key] = [];
                            } else {
                                stopRouteMappingCache[key] = await res.json();
                            }
                        } catch (err) {
                            console.error("stop_route_mapping fetch error", err);
                            stopRouteMappingCache[key] = [];
                        }
                    }
                    for (const rid of stopRouteMappingCache[key]) {
                        routeSet.add(String(rid));
                    }
                })
            );
            return Array.from(routeSet).sort();
        }

        async function drawRoutesAndStopsForPolygon(stopIds, routeIds) {
            routesLayerGroup.clearLayers();
            stopsLayerGroup.clearLayers();
            routeLayerIndex = {};
            stopMarkerIndex = {};

            const bounds = [];
            const stopSet = new Set(stopIds.map(String));

            // Ensure route edges are loaded
            await Promise.all(
                routeIds.map(async (routeId) => {
                    if (!routeEdgesCache[routeId]) {
                        const url = `${ROUTE_EDGES_BASE}/${routeId}.json`;
                        try {
                            const res = await fetch(url);
                            if (!res.ok) {
                                console.warn("No route_edges for", routeId);
                                routeEdgesCache[routeId] = [];
                            } else {
                                routeEdgesCache[routeId] = await res.json();
                            }
                        } catch (err) {
                            console.error("route_edges fetch error", err);
                            routeEdgesCache[routeId] = [];
                        }
                    }
                })
            );

            routeIds.forEach((routeId) => {
                const edges = routeEdgesCache[routeId] || [];
                const meta = routesMetadata[routeId] || {};
                const baseColor = meta.color
                    ? `#${meta.color}`
                    : "#2980b9";

                routeLayerIndex[routeId] = [];
                const edgeSet = new Set(
                    edges.map(([a, b]) => `${a}_${b}`)
                );

                edges.forEach(([fromId, toId]) => {
                    const locA = stopLocations[fromId];
                    const locB = stopLocations[toId];
                    if (!locA || !locB) return;

                    const [latA, lonA] = locA;
                    const [latB, lonB] = locB;

                    bounds.push([latA, lonA], [latB, lonB]);

                    if (stopSet.has(String(fromId))) {
                        ensureStopMarker(String(fromId), locA, routeId);
                    }
                    if (stopSet.has(String(toId))) {
                        ensureStopMarker(String(toId), locB, routeId);
                    }

                    const hasReverse = edgeSet.has(`${toId}_${fromId}`);
                    const weight = hasReverse ? 5 : 3;
                    const opacity = hasReverse ? 1.0 : 0.9;

                    const line = L.polyline(
                        [
                            [latA, lonA],
                            [latB, lonB],
                        ],
                        {
                            color: baseColor,
                            weight,
                            opacity,
                        }
                    ).on("click", (e) => {
                        L.DomEvent.stopPropagation(e);
                        onRouteClick(routeId);
                    });

                    if (hasReverse) {
                        line.bindTooltip("Two-way connection", {
                            sticky: true,
                        });
                    } else {
                        const label = meta.name || `Route ${routeId}`;
                        line.bindTooltip(`${label} – direction`, {
                            sticky: true,
                        });
                    }

                    routesLayerGroup.addLayer(line);
                    routeLayerIndex[routeId].push(line);
                });
            });

            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [40, 40] });
            }

            // Keep stops visually on top of routes
            stopsLayerGroup.bringToFront();
        }

        function ensureStopMarker(stopId, loc, routeId) {
            const [lat, lon] = loc;
            if (!stopMarkerIndex[stopId]) {
                const meta = stopsMetadata[stopId] || {};
                const marker = L.circleMarker([lat, lon], {
                    radius: 6,
                    color: "#34495e",
                    fillColor: "#3498db",
                    fillOpacity: 0.9,
                }).on("click", (e) => {
                    L.DomEvent.stopPropagation(e);
                    if (selectedRouteId) {
                        onStopClick(stopId);
                    }
                });

                marker.bindPopup(
                    `<b>${meta.name || "Stop " + stopId}</b><br/>Stop ID: ${stopId}`
                );

                stopsLayerGroup.addLayer(marker);
                stopMarkerIndex[stopId] = {
                    marker,
                    routes: new Set([routeId]),
                };
            } else {
                stopMarkerIndex[stopId].routes.add(routeId);
            }
        }

        // --- Route & stop selection -----------------------------------------

        function onRouteClick(routeId) {
            selectedRouteId = routeId;
            updateSelectedRouteInfo();
            styleRoutesAndStopsForSelection();
            populateStopList(routeId);

            // Hide polygons while a route is in focus
            if (polygonsLayer && map.hasLayer(polygonsLayer)) {
                map.removeLayer(polygonsLayer);
            }
        }

        function populateRouteList(routeIds) {
            const container = document.getElementById("route-list");
            container.innerHTML = "";
            routeIds.forEach((rid) => {
                const meta = routesMetadata[rid] || {};
                const label = meta.name || rid;
                const btn = document.createElement("button");
                btn.className = "pill-button";
                btn.textContent = label;
                btn.onclick = () => onRouteClick(rid);
                container.appendChild(btn);
            });
        }

        function populateStopList(routeId) {
            const stopSection = document.getElementById("stop-list-section");
            const routeSection = document.getElementById("route-list-section");
            const container = document.getElementById("stop-list");

            if (!selectedPolygonGid) return;

            const stopsInPolygon = new Set(
                (polygonStopMapping[selectedPolygonGid] || []).map(String)
            );
            const edges = routeEdgesCache[routeId] || [];
            const stopsForRoute = new Set();
            edges.forEach(([a, b]) => {
                if (stopsInPolygon.has(String(a))) stopsForRoute.add(String(a));
                if (stopsInPolygon.has(String(b))) stopsForRoute.add(String(b));
            });

            container.innerHTML = "";
            Array.from(stopsForRoute)
                .sort()
                .forEach((sid) => {
                    const meta = stopsMetadata[sid] || {};
                    const label = meta.name || sid;
                    const btn = document.createElement("button");
                    btn.className = "pill-button";
                    btn.textContent = label;
                    btn.onclick = () => onStopClick(sid);
                    container.appendChild(btn);
                });

            routeSection.style.display = "none";
            stopSection.style.display = "block";
        }

        function styleRoutesAndStopsForSelection() {
            // Routes
            Object.keys(routeLayerIndex).forEach((rid) => {
                const meta = routesMetadata[rid] || {};
                const baseColor = meta.color ? `#${meta.color}` : "#2980b9";
                const isSelected = selectedRouteId === rid;
                const opacity = isSelected ? 0.95 : 0.18;

                routeLayerIndex[rid].forEach((line) => {
                    line.setStyle({
                        color: baseColor,
                        opacity,
                        weight: 3,
                    });
                });
            });

            // Stops
            Object.keys(stopMarkerIndex).forEach((sid) => {
                const entry = stopMarkerIndex[sid];
                const isOnSelected =
                    selectedRouteId &&
                    entry.routes &&
                    entry.routes.has(selectedRouteId);
                const radius = isOnSelected ? 8 : 5;
                const fillOpacity = isOnSelected ? 0.9 : 0.25;

                entry.marker.setStyle({
                    radius,
                    fillOpacity,
                });
                if (entry.marker.bringToFront) {
                    entry.marker.bringToFront();
                }
            });
        }

        function updateSelectedRouteInfo() {
            const span = document.getElementById("selected-route-label");
            if (!selectedRouteId) {
                span.textContent = "Route: none";
                return;
            }
            const meta = routesMetadata[selectedRouteId] || {};
            span.textContent = `Route: ${meta.name || selectedRouteId}`;
        }

        function updateSelectedStopInfo() {
            const span = document.getElementById("selected-stop-label");
            if (!selectedStopId) {
                span.textContent = "Stop: none";
                return;
            }
            const meta = stopsMetadata[selectedStopId] || {};
            span.textContent = `Stop: ${
                meta.name || selectedStopId
            } (ID ${selectedStopId})`;
        }

        // --- Stop-level delay charts ----------------------------------------

        async function onStopClick(stopId) {
            if (!selectedRouteId) return;

            selectedStopId = stopId;
            updateSelectedStopInfo();

            const chartArea = document.getElementById("chart-area");
            chartArea.style.display = "grid";

            const [dir0Samples, dir1Samples] = await Promise.all([
                getDelaySamples(selectedRouteId, 0, stopId),
                getDelaySamples(selectedRouteId, 1, stopId),
            ]);

            renderChartsForDirection(
                dir0Samples,
                "hourlyDelayChartDir0",
                "dailyDelayChartDir0",
                "hourlyDir0Container",
                "dailyDir0Container"
            );
            renderChartsForDirection(
                dir1Samples,
                "hourlyDelayChartDir1",
                "dailyDelayChartDir1",
                "hourlyDir1Container",
                "dailyDir1Container"
            );
        }

        async function getDelaySamples(routeId, directionId, stopId) {
            const url = `${ROUTE_DIR_STOP_DELAY_BASE}/${routeId}/${directionId}/${stopId}.json`;
            try {
                const res = await fetch(url);
                if (!res.ok) {
                    console.warn(
                        "No delay data for",
                        routeId,
                        directionId,
                        stopId
                    );
                    return [];
                }
                const raw = await res.json();
                // raw: [[unix_time, delay_in_seconds], ...]
                return raw.map(([t, d]) => ({
                    t: new Date(t * 1000),
                    delay: -d, // flip polarity for this UI
                }));
            } catch (err) {
                console.error("getDelaySamples error", err);
                return [];
            }
        }

        function renderChartsForDirection(
            samples,
            hourlyCanvasId,
            dailyCanvasId,
            hourlyContainerId,
            dailyContainerId
        ) {
            const hourlyContainer = document.getElementById(hourlyContainerId);
            const dailyContainer = document.getElementById(dailyContainerId);

            if (!samples || samples.length === 0) {
                // Hide both containers if no data
                hourlyContainer.style.display = "none";
                dailyContainer.style.display = "none";
                destroyChart(hourlyCanvasId);
                destroyChart(dailyCanvasId);
                return;
            }

            const hourly = aggregateByHour(samples);
            const daily = aggregateByDay(samples);

            hourlyContainer.style.display = "block";
            dailyContainer.style.display = "block";

            destroyChart(hourlyCanvasId);
            destroyChart(dailyCanvasId);

            if (hourly.labels.length > 0) {
                const chart = renderLineChartWithBand(
                    hourlyCanvasId,
                    hourly.labels,
                    hourly.median,
                    hourly.mad,
                    "Median delay"
                );
                if (hourlyCanvasId === "hourlyDelayChartDir0")
                    hourlyDelayChartDir0 = chart;
                if (hourlyCanvasId === "hourlyDelayChartDir1")
                    hourlyDelayChartDir1 = chart;
            }

            if (daily.labels.length > 0) {
                const chart = renderLineChartWithBand(
                    dailyCanvasId,
                    daily.labels,
                    daily.median,
                    daily.mad,
                    "Median delay"
                );
                if (dailyCanvasId === "dailyDelayChartDir0")
                    dailyDelayChartDir0 = chart;
                if (dailyCanvasId === "dailyDelayChartDir1")
                    dailyDelayChartDir1 = chart;
            }
        }

        function destroyChart(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext("2d");
            if (!ctx) return;
            // We track references explicitly, so destroy them there
            switch (canvasId) {
                case "hourlyDelayChartDir0":
                    if (hourlyDelayChartDir0) hourlyDelayChartDir0.destroy();
                    hourlyDelayChartDir0 = null;
                    break;
                case "hourlyDelayChartDir1":
                    if (hourlyDelayChartDir1) hourlyDelayChartDir1.destroy();
                    hourlyDelayChartDir1 = null;
                    break;
                case "dailyDelayChartDir0":
                    if (dailyDelayChartDir0) dailyDelayChartDir0.destroy();
                    dailyDelayChartDir0 = null;
                    break;
                case "dailyDelayChartDir1":
                    if (dailyDelayChartDir1) dailyDelayChartDir1.destroy();
                    dailyDelayChartDir1 = null;
                    break;
            }
        }

        function clearCharts() {
            destroyChart("hourlyDelayChartDir0");
            destroyChart("hourlyDelayChartDir1");
            destroyChart("dailyDelayChartDir0");
            destroyChart("dailyDelayChartDir1");

            document.getElementById("hourlyDir0Container").style.display =
                "none";
            document.getElementById("hourlyDir1Container").style.display =
                "none";
            document.getElementById("dailyDir0Container").style.display =
                "none";
            document.getElementById("dailyDir1Container").style.display =
                "none";

            document.getElementById("chart-area").style.display = "none";
        }

        // Aggregation helpers: median + MAD
        function aggregateByHour(samples) {
            const buckets = {};
            samples.forEach(({ t, delay }) => {
                const h = t.getHours();
                const key = h.toString().padStart(2, "0") + ":00";
                if (!buckets[key]) buckets[key] = [];
                buckets[key].push(delay);
            });
            const labels = Object.keys(buckets).sort();
            const medianVals = [];
            const madVals = [];
            labels.forEach((k) => {
                const vals = buckets[k];
                const med = median(vals);
                const madVal = mad(vals, med);
                medianVals.push(med);
                madVals.push(madVal);
            });
            return { labels, median: medianVals, mad: madVals };
        }

        function aggregateByDay(samples) {
            const buckets = {};
            samples.forEach(({ t, delay }) => {
                const key = t.toISOString().slice(0, 10); // YYYY-MM-DD
                if (!buckets[key]) buckets[key] = [];
                buckets[key].push(delay);
            });
            const labels = Object.keys(buckets).sort();
            const medianVals = [];
            const madVals = [];
            labels.forEach((k) => {
                const vals = buckets[k];
                const med = median(vals);
                const madVal = mad(vals, med);
                medianVals.push(med);
                madVals.push(madVal);
            });
            return { labels, median: medianVals, mad: madVals };
        }

        function median(arr) {
            if (!arr || arr.length === 0) return null;
            const a = [...arr].sort((x, y) => x - y);
            const n = a.length;
            const mid = Math.floor(n / 2);
            if (n % 2 === 1) return a[mid];
            return 0.5 * (a[mid - 1] + a[mid]);
        }

        function mad(arr, med) {
            if (!arr || arr.length === 0 || med == null) return 0;
            const devs = arr.map((v) => Math.abs(v - med));
            return median(devs);
        }

        function renderLineChartWithBand(
            canvasId,
            labels,
            seriesVals,
            bandVals,
            label
        ) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;
            const ctx = canvas.getContext("2d");

            const upper = seriesVals.map((v, i) =>
                v != null && bandVals[i] != null ? v + bandVals[i] : null
            );
            const lower = seriesVals.map((v, i) =>
                v != null && bandVals[i] != null ? v - bandVals[i] : null
            );

            const validVals = seriesVals.filter(
                (v) => v != null && isFinite(v)
            );
            const yMin = validVals.length ? Math.min(...validVals) : undefined;
            const yMax = validVals.length ? Math.max(...validVals) : undefined;

            return new Chart(ctx, {
                type: "line",
                data: {
                    labels,
                    datasets: [
                        {
                            label,
                            data: seriesVals,
                            borderWidth: 2,
                            pointRadius: 3,
                            fill: false,
                            tension: 0.25,
                            borderColor: "#3498db",
                            backgroundColor: "#3498db",
                        },
                        {
                            label: "Lower",
                            data: lower,
                            borderWidth: 0,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.25,
                        },
                        {
                            label: "MAD band",
                            data: upper,
                            borderWidth: 0,
                            pointRadius: 0,
                            fill: "-1", // fill between this and previous dataset
                            tension: 0.25,
                            backgroundColor: "rgba(231, 76, 60, 0.22)",
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: { bottom: 40 },
                    },
                    plugins: {
                        legend: {
                            labels: {
                                filter: (item) => item.datasetIndex === 0,
                            },
                        },
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                autoSkip: true,
                                maxTicksLimit: 8,
                                padding: 20,
                            },
                            title: {
                                display: true,
                                text:
                                    labels.length &&
                                    typeof labels[0] === "string" &&
                                    labels[0].includes(":")
                                        ? "Hour of day"
                                        : "Date",
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Delay (sec, polarity flipped)",
                            },
                            suggestedMin: yMin,
                            suggestedMax: yMax,
                        },
                    },
                },
            });
        }

        // --- Clear button ----------------------------------------------------

        function clearRouteSelection() {
            selectedRouteId = null;
            selectedStopId = null;

            updateSelectedRouteInfo();
            updateSelectedStopInfo();
            clearCharts();

            // Clear routes & stops from map
            routesLayerGroup.clearLayers();
            stopsLayerGroup.clearLayers();
            routeLayerIndex = {};
            stopMarkerIndex = {};

            // Hide route & stop lists
            document.getElementById("route-list-section").style.display =
                "none";
            document.getElementById("stop-list-section").style.display = "none";

            // Bring polygons back if hidden
            if (polygonsLayer && !map.hasLayer(polygonsLayer)) {
                polygonsLayer.addTo(map);
            }
        }
    </script>
</body>
</html>
